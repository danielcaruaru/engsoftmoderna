{
"title": "Cap. 5 - Princípios de Projeto",  
"questions": [
  {
    "text": "Uma maneira de atingir integridade conceitual é por meio de um projeto dirigido por comitês.",
    "correct": "false"
  },
  {
    "text": "A implementação de uma classe deve encapsular estruturas de dados e algoritmos que são sujeitos a mudanças.",
    "correct": "true"
  },
  {
    "text": "Desenvolvimento em paralelo, isto é, a possibilidade de desenvolver ao mesmo tempo diversas classes de um sistema, é uma das vantagens de ocultamento de informação.",
    "correct": "true"
  },
  {
    "text": "Getters e setters são essenciais para construção de classes com ocultamento de informação. Sem eles, uma classe não atende a essa propriedade de projeto.",
    "correct": "false"
  },
  {
    "text": "Coesão e separação de interesses são conceitos antagônicos.",
    "correct": "false"
  },
  {
    "text": "Acoplamento estrutural ocorre quando uma classe A referencia em sua implementação uma classe B. Por exemplo, declara um atributo ou parâmetro do tipo B ou cria um objeto do tipo B, dentre outras situações.",
    "correct": "true"
  },
  {
    "text": "Todo acoplamento estrutural é evolutivo, mas o contrário nem sempre é verdade.",
    "correct": "false"
  },
  {
    "text": "Segregação de Variáveis e Responsabilidade Única são princípios úteis para obter classes coesas.",
    "correct": "false"
  },
  {
    "text": "O Princípio de Substituição de Liskov aplica-se apenas a linguagens com herança.",
    "correct": "true"
  },
  {
    "text": "Um nome mais intuitivo para Inversão de Dependências é Prefira Composição a Herança.",
    "correct": "false"
  },
  {
    "text": "Herança de classes envolve reúso de código, pois subclasses não precisam reimplementar métodos herdados. Já herança de interfaces não envolve reúso de código, pois, por definição, interfaces não incluem implementações.",
    "correct": "true"
  },
  {
    "text": "Composição é um mecanismo de reúso caixa-branca.",
    "correct": "false"
  },
  {
    "text": "Uma chamada obj.getX.getY().getZ().metodo() representa uma violação do Princípio de Demeter.",
    "correct": "true"
  },
  {
    "text": "De acordo com o Princípio Aberto/Fechado, uma classe deve ser aberta para modificações, mas fechada para extensões.",
    "correct": "false"
  },
  {
    "text": "Quando calcula-se o LCOM de uma classe, deve-se excluir métodos getters e setters.",
    "correct": "false"
  } 
]
}	    